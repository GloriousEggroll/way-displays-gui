#!/usr/bin/env python3

from ctypes import CDLL
CDLL('libgtk4-layer-shell.so')

import gi
import os
import yaml
import time
import socket
import math
import cairo

gi.require_version('Pango', '1.0')
gi.require_version("Gtk", "4.0")
gi.require_version("Gdk", "4.0")
gi.require_version("Gtk4LayerShell", "1.0")
from gi.repository import Gtk, Gdk, Gio, GObject, Gtk4LayerShell, GLib, Pango

SOCKET_PATH = os.path.expandvars("$XDG_RUNTIME_DIR/way-displays.$XDG_VTNR.sock")
if not os.path.exists(SOCKET_PATH):
    SOCKET_PATH = os.path.expandvars("$XDG_RUNTIME_DIR/way-displays.sock")
SOCKET_CHUNK_LEN = 8192

CONFIG_DATA = {}

def ipc_operation(operation, payload=""):
    raw = b''

    with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as client:
        try:

            # attempt to send to the socket
            client.connect(SOCKET_PATH)
            client.send(f"OP: {operation}\n{payload}".encode("utf-8"))

            # read responses until the server is done
            chunk = None
            while chunk != b'':
                chunk = client.recv(SOCKET_CHUNK_LEN);
                raw += chunk

        except FileNotFoundError:
            print(f"way-displays socket {SOCKET_PATH} not found. Is the server running? Are $WAYLAND_DISPLAY and $XDG_VTNR set?")

    return raw.decode("utf-8")

# This function is in case we need to refresh the data (like after saving changes)
# This way we shouldn't have to spam IPC calls
def get_config_data():
    global CONFIG_DATA
    try:
        data = yaml.safe_load(ipc_operation("GET"))
        if data:
            CONFIG_DATA = data
        return True
    except Exception as e:
        print(f"Failed to load config data: {str(e)}")
        return False

get_config_data() # call once to store data upon opening app

# more important hard to find docs
# https://github.com/wmww/gtk4-layer-shell/blob/main/examples/simple-example.py
# https://wmww.github.io/gtk4-layer-shell/gtk4-layer-shell-GTK4-Layer-Shell.html#gtk-layer-init-for-window
class MonitorOverlay(Gtk.Window):
    def __init__(self, monitor, label_text):
        super().__init__()
        self.set_title("MonitorOverlay")
        self.set_decorated(False)
        self.set_resizable(False)
        self.set_focusable(False)

        # Init layer shell
        Gtk4LayerShell.init_for_window(self)

        # Place it at the top layer (above everything)
        Gtk4LayerShell.set_layer(self, Gtk4LayerShell.Layer.TOP)

        # Pin to all edges (optional)
        Gtk4LayerShell.set_anchor(self, Gtk4LayerShell.Edge.TOP, True)
        Gtk4LayerShell.set_anchor(self, Gtk4LayerShell.Edge.LEFT, True)

        # Click-through
        Gtk4LayerShell.set_keyboard_mode(self, Gtk4LayerShell.KeyboardMode.NONE)

        # Bind to specific monitor
        display = Gdk.Display.get_default()
        Gtk4LayerShell.set_monitor(self, monitor)

        # Transparent background
        self.set_name("overlay-window")

        # CSS
        css = b"""
        window#overlay-window {
            background-color: rgba(0, 0, 0, 0.0);  /* fully transparent */
        }

        .overlay-box {
            background-color: rgba(0, 0, 0, 0.85);
            border-radius: 10px;
            padding: 16px;
        }

        .overlay-label {
            color: white;
            font-size: 16pt;
            font-weight: bold;
        }
        """
        provider = Gtk.CssProvider()
        provider.load_from_data(css)
        Gtk.StyleContext.add_provider_for_display(
            display,
            provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        # Build UI
        overlay = Gtk.Overlay()
        self.set_child(overlay)

        label_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        label_box.add_css_class("overlay-box")
        label_box.set_valign(Gtk.Align.CENTER)
        label_box.set_halign(Gtk.Align.CENTER)

        # Dynamically calculate 10% size of monitor
        rect = monitor.get_geometry()
        width = max(1, int(rect.width * 0.15))
        height = max(1, int(rect.height * 0.15))

        label_box.set_size_request(width, height)

        label = Gtk.Label(label=label_text)
        label.set_wrap(True)
        label.set_wrap_mode(Gtk.WrapMode.WORD)
        label.add_css_class("overlay-label")

        label_box.append(label)
        overlay.set_child(label_box)


class MonitorWidget(Gtk.Box):
    def __init__(self, monitor, on_enabled_toggle=None, on_transform_change=None, on_resolution_change=None, layout_area=None):
        super().__init__(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        self._on_resolution_change = on_resolution_change
        self.monitor = monitor
        self.set_margin_top(12)
        self.set_margin_bottom(12)
        self._on_transform_change = on_transform_change
        self.flip_switch = None
        self.layout_area = layout_area

        desc = monitor.get('DESCRIPTION', 'Unknown')
        make = monitor.get('MAKE', '')
        model = monitor.get('MODEL', '')
        name = monitor.get('NAME', '')

        # Header label
        label = Gtk.Label(label=f"{make} {model} ({name})")
        if not make or not model:
            label = Gtk.Label(label=f"Unknown ({name})")
        label.set_halign(Gtk.Align.START)
        self.append(label)

        # ------------------ Resolution Combo ------------------
        # Create the DropDown
        self.res_combo = Gtk.DropDown()

        # Create a Gtk.StringList for the model
        model = Gtk.StringList()   # <--- THIS must be Gtk.StringList, not a string

        modes = monitor.get('MODES', [])
        current_mode = monitor.get('CURRENT', {}).get('MODE', {})
        current_width = current_mode.get('WIDTH')
        current_height = current_mode.get('HEIGHT')
        current_refresh = current_mode.get('REFRESH_MHZ')
        current_index = 0

        for i, mode in enumerate(modes):
            width = mode.get('WIDTH')
            height = mode.get('HEIGHT')
            refresh = mode.get('REFRESH_MHZ', 60000) / 1000.0
            mode_str = f"{width}x{height} @ {refresh:.2f}Hz"

            model.append(mode_str)  # append string to StringList

            if (width == current_width and height == current_height and mode.get('REFRESH_MHZ') == current_refresh):
                current_index = i

        # Assign the model to the DropDown
        self.res_combo.set_model(model)
        self.res_combo.set_selected(current_index)
        self.res_combo.set_halign(Gtk.Align.START)
        self.append(self.res_combo)

        # ------------------ Enabled Switch ------------------
        enabled = monitor.get('CURRENT', {}).get('ENABLED')
        self.enable_switch = Gtk.Switch()
        self.enable_switch.set_active(enabled)
        self.enable_switch.connect("notify::active", self._on_enabled_toggled)
        self._on_enabled_toggle = on_enabled_toggle

        self.append(Gtk.Label(label="Enabled"))

        align_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        align_box.set_halign(Gtk.Align.START)
        align_box.append(self.enable_switch)
        self.append(align_box)

        # ------------------ VRR Switch ------------------
        vrr_state = monitor.get('CURRENT', {}).get('VRR', False)
        self.vrr_switch = Gtk.Switch()
        self.vrr_switch.set_active(vrr_state)
        self.append(Gtk.Label(label="Adaptive Sync (VRR)"))

        vrr_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        vrr_box.set_halign(Gtk.Align.START)
        vrr_box.append(self.vrr_switch)
        self.append(vrr_box)

        # ------------------ Orientation Buttons ------------------
        self.append(Gtk.Label(label="Orientation:"))

        rotation_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        self.append(rotation_box)

        self.rotation_buttons = {}
        rotations = [
            ("None", "view-fullscreen-symbolic"),           # 0Â°
            ("90", "object-rotate-right-symbolic"),         # 90Â°
            ("180", "view-refresh-symbolic"),               # 180Â°
            ("270", "object-rotate-left-symbolic"),         # 270Â°
        ]

        self.rotation_group = []  # for style toggling
        for rotation, icon in rotations:
            btn = Gtk.ToggleButton()
            image = Gtk.Image.new_from_icon_name(icon)
            btn.set_child(image)
            btn.set_tooltip_text(f"Rotate {rotation}Â°" if rotation != "None" else "No rotation")
            btn.connect("toggled", self.on_rotation_selected, rotation)
            self.rotation_buttons[rotation] = btn
            self.rotation_group.append(btn)
            rotation_box.append(btn)

        css_provider = Gtk.CssProvider()
        css_provider.load_from_data(b"""
            .orientation-button:checked {
                background-color: #666;
                border-radius: 4px;
            }
            .rotate-90 {
                transform: rotate(90deg);
            }
            .rotate-180 {
                transform: rotate(180deg);
            }
            .rotate-270 {
                transform: rotate(270deg);
            }
        """)
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        for btn in self.rotation_group:
            btn.add_css_class("orientation-button")

        self.rotation_buttons["None"].set_active(True)

        # ------------------ Flipped Toggle ------------------
        self.flip_switch = Gtk.Switch()
        self.flip_switch.connect("notify::active", self.on_flip_toggled)
        self.append(Gtk.Label(label="Flip"))

        flip_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL)
        flip_box.set_halign(Gtk.Align.START)
        flip_box.append(self.flip_switch)
        self.append(flip_box)

        # ------------------ Load Initial Transform from Config ------------------
        transform = monitor.get("CURRENT", {}).get("TRANSFORM")
        if transform:
            if "FLIPPED" in str(transform).upper():
                self.flip_switch.set_active(True)
                if "-" in transform:
                    rot = transform.split("-")[1].upper()
                else:
                    rot = "None"
            else:
                rot = str(transform).upper()

            if rot in ["90", "180", "270"]:
                self.rotation_buttons[rot].set_active(True)
            else:
                self.rotation_buttons["None"].set_active(True)

        # ------------------ Scale Slider ------------------
        scale_value = monitor.get("CURRENT", {}).get("SCALE", 1.0)
        adjustment = Gtk.Adjustment(value=scale_value, lower=1.0, upper=2.5, step_increment=0.25, page_increment=0.25, page_size=0)
        self.scale_slider = Gtk.Scale(
            orientation=Gtk.Orientation.HORIZONTAL,
            adjustment=adjustment
        )
        self.scale_slider.add_css_class("scale-slider")
        self.scale_slider.set_round_digits(2)
        self.scale_slider.set_draw_value(False)
        self.scale_slider.set_value_pos(Gtk.PositionType.RIGHT)
        self.scale_slider.set_hexpand(True)
        self.scale_slider.set_margin_top(6)
        self.scale_slider.set_margin_bottom(6)

        for val in [1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5]:
            self.scale_slider.add_mark(val, Gtk.PositionType.BOTTOM, f"{val:.2f}")

        self.scale_slider.connect("value-changed", self.on_scale_value_changed)

        self.append(Gtk.Label(label="Scale Override"))
        self.append(self.scale_slider)

        if self._on_transform_change:
            self._on_transform_change(self.monitor.get("DESCRIPTION"), self.get_transform())

        self.res_combo.connect("notify::selected", self.on_resolution_changed)


    # ------------------ Methods ------------------

    def on_resolution_changed(self, dropdown, param):
        selected_index = dropdown.get_selected()
        if selected_index < 0:
            return  # Nothing selected

        # Get the mode object from the monitor's MODES list
        modes = self.monitor.get('MODES', [])
        if selected_index >= len(modes):
            return
        mode = modes[selected_index]

        width = mode.get("WIDTH", 1920)
        height = mode.get("HEIGHT", 1080)
        refresh_mhz = mode.get("REFRESH_MHZ", 60000)
        refresh_hz = refresh_mhz / 1000.0

        # Update internal monitor state
        self.monitor["CURRENT"]["MODE"] = {
            "WIDTH": width,
            "HEIGHT": height,
            "REFRESH_MHZ": refresh_mhz
        }

        # ðŸ”¥ IMMEDIATE VISUAL FEEDBACK
        if self.layout_area:
            widget = self.layout_area.get_widget_by_desc(self.monitor["DESCRIPTION"])
            if widget:
                data = self.layout_area.monitor_data.get(widget)
                if data:
                    # Update dimensions
                    scale = 0.08
                    new_w = int(width * scale)
                    new_h = int(height * scale)
                    data["width"] = new_w
                    data["height"] = new_h
                    data["refresh"] = refresh_mhz

                    if widget.get_parent() == self.layout_area:
                        self.layout_area.move(widget, data["x"], data["y"])  # preserve pos
                        widget.set_size_request(new_w, new_h)

                    # Update label text
                    label = data.get("label")
                    if label:
                        label.set_text(f"{self.monitor['DESCRIPTION']}\n{width}x{height} @ {refresh_hz:.0f}Hz")

        # Optional: call your snapping logic again if needed
        self.layout_area._snap_monitors_to_edges()



    def _on_resolution_change(self, desc, new_width, new_height, refresh):
        print(0)
        if not self.layout_area:
            return
        scale = 0.08
        widget = self.layout_area.get_widget_by_desc(desc)
        if not widget:
            return
        for w, data in self.layout_area.monitor_data.items():
            if data["desc"] == desc:
                data["width"] = int(new_width * scale)
                data["height"] = int(new_height * scale)
                data["refresh"] = int(refresh * 1000)
                self.layout_area._apply_transform_to_shape(w, data.get("transform"))

                # Update the label text
                frame = w.get_child()
                box = frame.get_child()
                label = box.get_children()[0]

                label.set_text(f"{desc}\n{new_width}x{new_height} @ {refresh:.0f}Hz")
                break



    def on_flip_toggled(self, switch, _param):
        if self._on_transform_change:
            self._on_transform_change(self.monitor.get("DESCRIPTION"), self.get_transform())

    def _on_enabled_toggled(self, switch, gparam):
        enabled = switch.get_active()

        if "CURRENT" not in self.monitor:
            self.monitor["CURRENT"] = {}
        self.monitor["CURRENT"]["ENABLED"] = enabled

        if self._on_enabled_toggle:
            self._on_enabled_toggle(self.monitor, enabled)


    def on_rotation_selected(self, btn, rotation):
        # Only proceed if the clicked button was just activated
        if not btn.get_active():
            return

        # Block signals temporarily so toggling others doesn't re-trigger this callback
        for key, other_btn in self.rotation_buttons.items():
            if other_btn is not btn:
                other_btn.handler_block_by_func(self.on_rotation_selected)
                other_btn.set_active(False)
                other_btn.handler_unblock_by_func(self.on_rotation_selected)

        # Apply the transform immediately
        if self._on_transform_change:
            self._on_transform_change(self.monitor.get("DESCRIPTION"), self.get_transform())

    def on_scale_value_changed(self, scale):
        value = scale.get_value()
        snapped = round(value * 4) / 4
        if abs(snapped - value) > 0.001:
            scale.set_value(snapped)

    def get_transform(self):
        rotation = None
        for key, btn in self.rotation_buttons.items():
            if btn.get_active():
                rotation = key
                break

        flipped = False
        if hasattr(self, "flip_switch") and self.flip_switch:
            flipped = self.flip_switch.get_active()

        if not rotation or rotation == "None":
            return "FLIPPED" if flipped else None

        transform = rotation
        if flipped:
            transform = f"FLIPPED-{rotation}"

        return transform


    def get_desired_state(self):
        selected_index = self.res_combo.get_selected()

        # Make sure selection is valid
        modes = self.monitor.get("MODES", [])
        if selected_index is None or selected_index < 0 or selected_index >= len(modes):
            return None

        selected_mode = modes[selected_index]
        desc = self.monitor["DESCRIPTION"]

        return {
            "desc": desc,
            "width": selected_mode["WIDTH"],
            "height": selected_mode["HEIGHT"],
            "refresh": selected_mode["REFRESH_MHZ"],
            "enabled": self.enable_switch.get_active(),
            "vrr": self.vrr_switch.get_active(),
            "scale": self.scale_slider.get_value(),
            "transform": self.get_transform(),
        }

def snap_to_edges(x, y, rects, width, height, margin=0, snap_threshold=30):
    for rx, ry, rw, rh in rects:
        # Snap X axis
        if abs(x - (rx + rw)) <= snap_threshold:
            x = rx + rw + margin
        elif abs((x + width) - rx) <= snap_threshold:
            x = rx - width - margin

        # Snap Y axis
        if abs(y - (ry + rh)) <= snap_threshold:
            y = ry + rh + margin
        elif abs((y + height) - ry) <= snap_threshold:
            y = ry - height - margin

    return x, y


def rotated_dimensions(width, height, transform):
    """Returns width and height adjusted for rotation."""
    transform = str(transform)
    if transform in ("90", "270"):
        return height, width  # Swap if portrait
    return width, height

def parse_transform(transform_str):
    """
    Given a transform string like '90', 'FLIPPED', or 'FLIPPED-270',
    returns: (angle: int, is_flipped: bool)
    """
    angle = 0
    is_flipped = False

    if not transform_str:
        return angle, is_flipped

    transform_str = str(transform_str).upper()

    if "FLIPPED" in transform_str:
        is_flipped = True
        if "-" in transform_str:
            parts = transform_str.split("-")
            if len(parts) == 2 and parts[1].isdigit():
                angle = int(parts[1])
    elif transform_str.isdigit():
        angle = int(transform_str)

    return angle % 360, is_flipped

class MonitorLayout(Gtk.Fixed):
    def __init__(self, monitors, notebook, desc_to_tab_index, align=None, arrange=None, order=None, transform_overrides=None):
        super().__init__()
        self.align = (align or "TOP").upper()
        self.arrange = (arrange or "ROW").upper()
        self.notebook = notebook
        self.desc_to_tab_index = desc_to_tab_index
        self.monitor_data = {}
        self.drag_data = {}

        self.set_size_request(1280, 720)

        # CSS Setup
        css = b"""
        .monitor-frame {
            background-color: #4a90e2;
            border-radius: 6px;
        }
        .overlay-label {
            font-size: 10px;
            color: white;
        }
        .snap-flash {
            border: 2px solid #00ffff;
            border-radius: 4px;
            transition: border 100ms ease-in-out;
        }
        .rotate-0 {
            transform: rotate(0deg);
        }
        .rotate-90 {
            transform: rotate(90deg);
        }
        .rotate-180 {
            transform: rotate(180deg);
        }
        .rotate-270 {
            transform: rotate(270deg);
        }
        .flip-indicator {
            margin-top: -12px;
            margin-right: 4px;
        }
        """
        provider = Gtk.CssProvider()
        provider.load_from_data(css)
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        # --- Config Loading ---
        self.transform_overrides = transform_overrides or {}
        config_order = []
        if os.path.exists(SOCKET_PATH):
            data = CONFIG_DATA
            cfg = data.get("CFG", {})
            self.align = (cfg.get("ALIGN", self.align)).upper()
            self.arrange = (cfg.get("ARRANGE", self.arrange)).upper()
            config_order = cfg.get("ORDER", [])
            disabled = cfg.get("DISABLED", [])

        order = order or config_order
        self._current_order = order

        monitor_map = {m["DESCRIPTION"]: m for m in monitors}
        ordered_monitors = []
        seen = set()

        for desc in order:
            if desc in monitor_map:
                mon = monitor_map[desc].copy()
                mon["CURRENT"] = {}
                if desc in self.transform_overrides:
                    mon["CURRENT"]["TRANSFORM"] = self.transform_overrides[desc]
                ordered_monitors.append(mon)
                seen.add(desc)

        for desc, mon in monitor_map.items():
            if desc not in seen:
                mon = mon.copy()
                mon["CURRENT"] = {}
                if desc in self.transform_overrides:
                    mon["CURRENT"]["TRANSFORM"] = self.transform_overrides[desc]
                ordered_monitors.append(mon)

        scale = 0.08
        monitor_widgets = []

        for mon in ordered_monitors:
            name = mon["NAME"]
            desc = mon["DESCRIPTION"]
            mode = mon.get("DESIRED", {}).get("MODE", mon.get("CURRENT", {}).get("MODE", {}))
            width = mode.get("WIDTH", 1920)
            height = mode.get("HEIGHT", 1080)
            transform = mon.get("DESIRED", {}).get("TRANSFORM", mon.get("CURRENT", {}).get("TRANSFORM", 0))
            transform_str = str(transform).upper()
            angle, is_flipped = parse_transform(transform_str)
            if angle in (90, 270):
                width, height = height, width

            w, h = int(width * scale), int(height * scale)

            # === Label inside box ===
            label = Gtk.Label(label=name)
            label.set_wrap(True)
            label.set_wrap_mode(Pango.WrapMode.WORD)
            label.set_max_width_chars(20)
            label.set_halign(Gtk.Align.CENTER)
            label.set_valign(Gtk.Align.CENTER)

            box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
            box.set_halign(Gtk.Align.FILL)
            box.set_valign(Gtk.Align.FILL)
            box.add_css_class("monitor-frame")
            box.append(label)

            frame = Gtk.Frame()
            frame.set_child(box)
            frame.set_size_request(w, h)

            # === OUTER ROTATABLE CONTAINER ===
            rotatable = Gtk.Box()
            rotatable.set_halign(Gtk.Align.START)
            rotatable.set_valign(Gtk.Align.START)
            rotatable.set_size_request(w, h)
            rotatable.append(frame)

            # === Gesture support in GTK 4 ===
            gesture_click = Gtk.GestureClick()
            gesture_click.connect("pressed", self.on_shape_clicked, rotatable, desc)
            rotatable.add_controller(gesture_click)

            gesture_drag = Gtk.GestureDrag()
            gesture_drag.connect("drag-begin", self.on_drag_begin, rotatable)
            gesture_drag.connect("drag-update", self.on_drag_update, rotatable)
            gesture_drag.connect("drag-end", self.on_drag_end, rotatable)
            rotatable.add_controller(gesture_drag)

            if not disabled or desc not in disabled:
                monitor_widgets.append((rotatable, name, desc, w, h, width, height, order, transform))

            self.monitor_data[rotatable] = {
                "name": name,
                "desc": desc,
                "width": w,
                "height": h,
                "x": 0,
                "y": 0,
                "orig_width": width,
                "orig_height": height,
                "order": order,
                "transform": transform,
                "frame": frame,
                "box": box,
            }


        # --- Position monitors ---
        layout_w, layout_h = 1280, 720
        max_width = max(h for _, _, _, h, _, _, _, _, _ in monitor_widgets)
        max_height = max(h for _, _, _, _, h, _, _, _, _ in monitor_widgets)

        if self.arrange == "ROW":
            group_width = sum(w for _, _, _, w, _, _, _, _, _ in monitor_widgets)
            group_height = max_height
        else:
            group_width = max_width
            group_height = sum(h for _, _, _, _, h, _, _, _, _ in monitor_widgets)

        offset_x = (layout_w - group_width) // 2
        offset_y = (layout_h - group_height) // 2

        x_cursor = offset_x
        y_cursor = offset_y

        for rotatable, name, desc, w, h, orig_width, orig_height, order, transform in monitor_widgets:
            if self.arrange == "ROW":
                y = y_cursor
                if self.align == "MIDDLE":
                    y += (max_height - h) // 2
                elif self.align == "BOTTOM":
                    y += (max_height - h)
                x = x_cursor
                x_cursor += w
            else:
                x = x_cursor
                if self.align == "MIDDLE":
                    x += (max_width - w) // 2
                elif self.align == "RIGHT":
                    x += (max_width - w)
                y = y_cursor
                y_cursor += h

            self.put(rotatable, x, y)

            self.monitor_data[rotatable].update({"x": x, "y": y})

        self._snap_monitors_to_edges()  # If you have snapping logic

    def on_drag_begin(self, gesture, start_x, start_y, widget):
        if widget not in self.monitor_data:
            return

        x = start_x
        y = start_y
        width = widget.get_width()
        height = widget.get_height()

        self.drag_data = {
            "widget": widget,
            "dx": start_x,
            "dy": start_y,
            "start_x": x,
            "start_y": y,
            "width": width,
            "height": height,
            "desc": self.monitor_data[widget]["desc"],
            "name": self.monitor_data[widget]["name"],
            "order": self.monitor_data[widget]["order"],
        }


    def on_drag_update(self, gesture, delta_x, delta_y, widget):
        # Get current position using translate_coordinates
        parent = widget.get_parent()
        if parent:
            current_x, current_y = widget.translate_coordinates(parent, 0, 0)
        else:
            current_x = current_y = 0

        # Move relative to current allocation
        new_x = int(current_x + delta_x)
        new_y = int(current_y + delta_y)

        # Clamp to bounds
        layout_width = self.get_width()
        layout_height = self.get_height()
        width = self.monitor_data[widget]["width"]
        height = self.monitor_data[widget]["height"]

        new_x = max(0, min(new_x, layout_width - width))
        new_y = max(0, min(new_y, layout_height - height))

        if widget.get_parent() == self:
            self.move(widget, new_x, new_y)
        self.monitor_data[widget]["x"] = new_x
        self.monitor_data[widget]["y"] = new_y


    def on_drag_end(self, gesture, offset_x, offset_y, widget):
        # Get current position and size
        info = self.monitor_data[widget]
        x = info["x"]
        y = info["y"]
        w = info["width"]
        h = info["height"]

        # List of other monitor rectangles (x, y, width, height)
        other_rects = [
            (data["x"], data["y"], data["width"], data["height"])
            for wgt, data in self.monitor_data.items()
            if wgt != widget
        ]

        # Snap position
        x_snapped, y_snapped = snap_to_edges(x, y, other_rects, w, h)

        # Move the widget to snapped position
        if widget.get_parent() == self:
            self.move(widget, x_snapped, y_snapped)
        self.monitor_data[widget]["x"] = x_snapped
        self.monitor_data[widget]["y"] = y_snapped

        # Optional: visual feedback
        if (x, y) != (x_snapped, y_snapped):
            self.flash_widget_border(widget)


    def _move_widget_safely(self, widget, x, y):
        if widget.get_parent() == self:
            self.move(widget, x, y)
        self.monitor_data[widget]["x"] = x
        self.monitor_data[widget]["y"] = y
        return False  # Only run once


    def update_widget_transform(self, widget, transform):
        meta = self.monitor_data[widget]
        meta["transform"] = transform
        self._apply_transform_to_shape(widget, transform)


    def _apply_transform_to_shape(self, rotatable, transform):
        meta = self.monitor_data[rotatable]
        box = meta.get("box")

        for child in list(box):
            if isinstance(child, Gtk.Image) and child.get_name() == "flip-indicator":
                box.remove(child)

        angle, is_flipped = parse_transform(transform)

        # CSS classes for rotation
        for cls in ["rotate-0", "rotate-90", "rotate-180", "rotate-270"]:
            rotatable.remove_css_class(cls)

        # Reset to 0
        rotatable.add_css_class("rotate-0")

        # Reset again so we dont get stacked transforms
        rotatable.remove_css_class("rotate-0")

        if angle == 90:
            rotatable.add_css_class("rotate-90")
        elif angle == 180:
            rotatable.add_css_class("rotate-180")
        elif angle == 270:
            rotatable.add_css_class("rotate-270")

        # Flip indicator
        if is_flipped:
            flip_icon = Gtk.Image.new_from_icon_name("object-flip-vertical-symbolic")
            flip_icon.set_halign(Gtk.Align.END)
            flip_icon.set_valign(Gtk.Align.FILL)
            flip_icon.set_vexpand(True)
            flip_icon.set_name("flip-indicator")
            flip_icon.add_css_class("flip-indicator")
            flip_icon.is_flip_icon = True
            box.append(flip_icon)

    def add_monitor(self, monitor):
        desc = monitor["DESCRIPTION"]
        name = monitor["NAME"]

        # Skip if already present
        for child in self:
            child_data = self.monitor_data.get(child)
            if child_data and child_data["desc"] == desc:
                return

        # --- Monitor metadata ---
        mode = monitor.get("CURRENT", {}).get("MODE", {})
        width = mode.get("WIDTH", 1920)
        height = mode.get("HEIGHT", 1080)
        refresh = mode.get("REFRESH_MHZ", 60000) / 1000.0
        transform = self.transform_overrides.get(desc) or monitor.get("CURRENT", {}).get("TRANSFORM", 0)

        # Apply initial transform (rotate width/height if needed)
        angle, is_flipped = parse_transform(str(transform).upper())
        orig_width, orig_height = width, height
        if angle in (90, 270):
            width, height = height, width

        # --- Scaled sizes ---
        scale = 0.08
        w, h = int(width * scale), int(height * scale)

        # --- Visual frame ---
        frame = Gtk.Frame()
        frame.set_size_request(w, h)
        frame.add_css_class("monitor-frame")

        # Inner content box
        label = Gtk.Label(label=name)
        label.set_justify(Gtk.Justification.CENTER)

        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        box.set_halign(Gtk.Align.FILL)
        box.set_valign(Gtk.Align.FILL)
        box.set_hexpand(True)
        box.set_vexpand(True)
        box.append(label)
        frame.set_child(box)

        # --- Rotation container ---
        rotatable = Gtk.Box()
        rotatable.set_halign(Gtk.Align.START)
        rotatable.set_valign(Gtk.Align.START)
        rotatable.append(frame)

        # Apply rotation classes
        for cls in ["rotate-0", "rotate-90", "rotate-180", "rotate-270"]:
            rotatable.remove_css_class(cls)
        rotatable.add_css_class(f"rotate-{angle}")

        # --- Event handling (drag + click) ---
        gesture_click = Gtk.GestureClick()
        gesture_click.connect("pressed", self.on_shape_clicked, rotatable, desc)
        rotatable.add_controller(gesture_click)

        gesture_drag = Gtk.GestureDrag()
        gesture_drag.connect("drag-begin", self.on_drag_begin, rotatable)
        gesture_drag.connect("drag-update", self.on_drag_update, rotatable)
        gesture_drag.connect("drag-end", self.on_drag_end, rotatable)
        rotatable.add_controller(gesture_drag)

        # --- Initial position ---
        existing = list(self.monitor_data.values())
        arrange = getattr(self, "_current_arrange", "ROW").upper()

        if existing:
            if arrange == "ROW":
                max_x = max(d["x"] + d["width"] for d in existing)
                x = max_x + 20
                y = min(d["y"] for d in existing)
            else:
                max_y = max(d["y"] + d["height"] for d in existing)
                y = max_y + 20
                x = min(d["x"] for d in existing)
        else:
            x, y = 100, 100

        # --- Add to layout ---
        self.put(rotatable, x, y)

        # --- Store metadata ---
        self.monitor_data[rotatable] = {
            "desc": desc,
            "name": name,
            "monitor": monitor,
            "width": w,
            "height": h,
            "orig_width": orig_width,
            "orig_height": orig_height,
            "x": x,
            "y": y,
            "transform": transform,
            "box": box,
            "label": label,
            "frame": frame,
        }


    def remove_monitor(self, desc):
        for rotatable, data in list(self.monitor_data.items()):
            if data["desc"] == desc:
                if rotatable.get_parent() == self:
                    self.remove(rotatable)
                del self.monitor_data[rotatable]
                break



    def _snap_monitors_to_edges(self, tolerance=20):
        items = list(self.monitor_data.items())

        for i, (widget_a, data_a) in enumerate(items):
            ax, ay = data_a["x"], data_a["y"]
            aw, ah = data_a["width"], data_a["height"]

            for j, (widget_b, data_b) in enumerate(items):
                if i == j:
                    continue

                bx, by = data_b["x"], data_b["y"]
                bw, bh = data_b["width"], data_b["height"]

                # Snap left/right
                if abs((ax + aw) - bx) <= tolerance:
                    ax = bx - aw
                elif abs(ax - (bx + bw)) <= tolerance:
                    ax = bx + bw

                # Snap top/bottom
                if abs((ay + ah) - by) <= tolerance:
                    ay = by - ah
                elif abs(ay - (by + bh)) <= tolerance:
                    ay = by + bh

            if widget_a.get_parent() == self:
                self.move(widget_a, ax, ay)
            self.monitor_data[widget_a]["x"] = ax
            self.monitor_data[widget_a]["y"] = ay

    def recenter_all_monitors(self):
        if not self.monitor_data:
            return

        layout_width = self.get_allocated_width()
        layout_height = self.get_allocated_height()

        arrange = getattr(self, "_current_arrange", "ROW").upper()
        align = getattr(self, "_current_align", "TOP").upper()

        widgets = list(self.monitor_data.items())

        if arrange == "ROW":
            rotated_widgets = []
            total_width = 0
            for widget, data in widgets:
                transform = data.get("CURRENT", {}).get("TRANSFORM")
                w, h = rotated_dimensions(data["width"], data["height"], transform)
                total_width += w
                rotated_widgets.append((widget, w, h))

            start_x = (layout_width - total_width) // 2

            if align == "MIDDLE":
                center_y = layout_height // 2
                x = start_x
                for widget, w, h in rotated_widgets:
                    y = center_y - h // 2
                    if widget.get_parent() == self:
                        self.move(widget, x, y)
                    self.monitor_data[widget]["x"] = x
                    self.monitor_data[widget]["y"] = y
                    x += w

            elif align == "TOP":
                first_h = rotated_widgets[0][2]
                top_y = (layout_height // 2) - (first_h // 2)
                x = start_x
                for widget, w, h in rotated_widgets:
                    y = top_y
                    if widget.get_parent() == self:
                        self.move(widget, x, y)
                    self.monitor_data[widget]["x"] = x
                    self.monitor_data[widget]["y"] = y
                    x += w

            elif align == "BOTTOM":
                first_h = rotated_widgets[0][2]
                bottom_y = (layout_height // 2) + (first_h // 2)
                x = start_x
                for widget, w, h in rotated_widgets:
                    y = bottom_y - h
                    if widget.get_parent() == self:
                        self.move(widget, x, y)
                    self.monitor_data[widget]["x"] = x
                    self.monitor_data[widget]["y"] = y
                    x += w

        elif arrange == "COLUMN":
            rotated_widgets = []
            total_height = 0
            for widget, data in widgets:
                transform = data.get("CURRENT", {}).get("TRANSFORM")
                w, h = rotated_dimensions(data["width"], data["height"], transform)
                total_height += h
                rotated_widgets.append((widget, w, h))

            start_y = (layout_height - total_height) // 2

            if align == "MIDDLE":
                center_x = layout_width // 2
                y = start_y
                for widget, w, h in rotated_widgets:
                    x = center_x - w // 2
                    if widget.get_parent() == self:
                        self.move(widget, x, y)
                    self.monitor_data[widget]["x"] = x
                    self.monitor_data[widget]["y"] = y
                    y += h

            elif align == "LEFT":
                first_w = rotated_widgets[0][1]
                left_x = (layout_width // 2) - (first_w // 2)
                y = start_y
                for widget, w, h in rotated_widgets:
                    x = left_x
                    if widget.get_parent() == self:
                        self.move(widget, x, y)
                    self.monitor_data[widget]["x"] = x
                    self.monitor_data[widget]["y"] = y
                    y += h

            elif align == "RIGHT":
                first_w = rotated_widgets[0][1]
                right_x = (layout_width // 2) + (first_w // 2)
                y = start_y
                for widget, w, h in rotated_widgets:
                    x = right_x - w
                    if widget.get_parent() == self:
                        self.move(widget, x, y)
                    self.monitor_data[widget]["x"] = x
                    self.monitor_data[widget]["y"] = y
                    y += h



    def flash_widget_border(self, widget):
        widget.add_css_class("snap-flash")
        GLib.timeout_add(150, lambda: widget.remove_css_class("snap-flash") or False)

    def get_widget_by_desc(self, desc):
        for widget, data in self.monitor_data.items():
            if data["desc"] == desc:
                return widget
        return None

    def on_resize_recenter(self, widget, allocation):
        new_w, new_h = allocation.width, allocation.height
        if (new_w, new_h) != self.last_allocated_size:
            GLib.idle_add(self.recenter_all_monitors)
            self.last_allocated_size = (new_w, new_h)

    def get_positions(self):
        return {
            data["desc"]: (data["x"], data["y"])
            for widget, data in self.monitor_data.items()
        }

    def on_shape_clicked(self, gesture, n_press, x, y, widget, desc):
        if self.desc_to_tab_index and desc in self.desc_to_tab_index:
            self.notebook.set_current_page(self.desc_to_tab_index[desc])

    def show_overlay(self, desc, width, height, x, y, orig_width, orig_height, name):
        data = CONFIG_DATA
        cfg = data.get("CFG", {})
        order = cfg.get("ORDER", [])
        disabled = cfg.get("DISABLED", [])
        monitor = None

        # Get the default display
        display = Gdk.Display.get_default()
        monitors = display.get_monitors()  # This returns a list of monitor objects

        # Iterate over each monitor
        for i, mon in enumerate(monitors):
            if desc in mon.get_description():
                monitor = mon
                break;
            # this docusmentation was hard to find.
            # https://docs.gtk.org/gdk4-wayland/class.WaylandMonitor.html

            # Get the monitor geometry
            #rect = mon.get_geometry()

            # Get description
            #mon_desc = mon.get_description()

            # Get description
            #mon_display = mon.get_display()

            # Get the scale factor (for high DPI displays)
            #scale_factor = mon.get_scale_factor()

            # Get connector name (e.g., VGA, HDMI, DisplayPort)
            #connector = mon.get_connector()

            #print(f"\nMonitor {i}:")
            #print(f"  Description: {mon_desc}")
            #print(f"  Connector: {connector}")
            #print(f"  Display: {display}")
            #print(f"  Scale Factor: {scale_factor}")
            #print(f"  Geometry:")
            #print(f"    Position: ({rect.x}, {rect.y})")
            #print(f"    Size: {rect.width}x{rect.height}")

        if monitor:
            # Use your custom class
            label_text = f"{name}\n{orig_width}x{orig_height}"
            overlay = MonitorOverlay(monitor, f"{label_text}")
            overlay.present()
            # Click-through overlay.
            # https://github.com/wmww/gtk4-layer-shell/issues/61#issuecomment-3092952852
            overlay.get_surface().set_input_region(cairo.Region())


class WayDisplaysApp(Gtk.ApplicationWindow):
    def __init__(self, application):
        super().__init__(application=application)
        self.set_title("Way Displays GUI")
        self.set_default_size(1280, 1000)
        self.set_resizable(True)
        self.set_decorated(True)

        # === HeaderBar ===
        header = Gtk.HeaderBar()
        header.set_title_widget(Gtk.Label(label="Way Displays GUI"))
        header.set_show_title_buttons(True)
        self.set_titlebar(header)

        # === Notebook + Layout ===
        self.monitors_notebook = Gtk.Notebook()
        self.monitor_widgets = []
        self.monitor_tabs = {}
        self.monitor_tab_indices = {}

        self.layout_area = None
        self.layout_frame = Gtk.Frame()
        self.layout_frame.set_hexpand(True)
        self.layout_frame.set_vexpand(True)

        # === Notification Bar ===
        notif_bar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12, margin_start=12, margin_end=12, margin_top=6, margin_bottom=6)

        self.notify_toggle = Gtk.Switch(hexpand=False, halign=Gtk.Align.END)
        notif_bar.append(self.notify_toggle)
        notif_bar.append(Gtk.Label(label="Enable Notifications"))

        notif_bar.append(Gtk.Label(label="Notification CMD:"))

        self.callback_entry = Gtk.Entry(hexpand=True)
        notif_bar.append(self.callback_entry)

        self.callback_entry.connect("changed", self.on_callback_entry_changed)
        self.notify_toggle.connect("notify::active", self.on_notify_toggle)

        callback_cmd = ""
        data = CONFIG_DATA
        if data:
            cfg = data.get("CFG", {})
            callback_cmd = cfg.get("CALLBACK_CMD", "")

        if callback_cmd:
            self.callback_entry.set_text(callback_cmd)
            self.notify_toggle.set_active(True)

        # === Auto Scale Bar ===
        auto_bar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=12, margin_start=12, margin_end=12, margin_top=6, margin_bottom=6)

        self.auto_scale_switch = Gtk.Switch()
        self.auto_scale_switch.connect("notify::active", self.on_autoscale_toggle)

        auto_bar.append(self.auto_scale_switch)
        auto_bar.append(Gtk.Label(label="Global Auto Scale (ignored if per-monitor scaling is set.)"))

        # === Save Button ===
        save_btn = Gtk.Button(label="Apply")
        save_btn.connect("clicked", self.save_config)

        save_bar = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, margin_start=12, margin_end=12, margin_top=6, margin_bottom=6)
        save_bar.append(save_btn)

        # === Main Content ===
        main_content = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        main_content.append(self.layout_frame)
        main_content.append(self.monitors_notebook)
        main_content.append(notif_bar)
        main_content.append(auto_bar)
        main_content.append(save_bar)

        scroll = Gtk.ScrolledWindow()
        scroll.set_name("main-scroll")
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        inner_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, margin_start=30, margin_end=30, margin_bottom=30)
        inner_box.append(main_content)
        scroll.set_child(inner_box)

        # === Outer Container ===
        outer_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        outer_box.append(scroll)
        self.set_child(outer_box)

        # === CSS ===
        css = b"""
        #custom-titlebar {
            background-color: #333336;
            padding: 6px;
        }

        #custom-titlebar GtkLabel {
            color: white;
            font-weight: bold;
        }

        #custom-titlebar GtkButton {
            background-color: transparent;
            border: none;
            color: white;
            margin: 0 4px;
            border-radius: 4px;
            padding: 2px 6px;
        }

        #custom-titlebar GtkButton:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }

        #main-scroll slider {
            min-width: 16px;
            min-height: 16px;
        }
        """

        provider = Gtk.CssProvider()
        provider.load_from_data(css)
        Gtk.StyleContext.add_provider_for_display(
            Gdk.Display.get_default(),
            provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        # === Start App Logic ===
        self.load_monitor_data()
        self.reload_layout()


    def load_monitor_data(self):
        data = CONFIG_DATA
        cfg = data.get("CFG", {})
        global_auto_scale = cfg.get("AUTO_SCALE", True)
        self.auto_scale_switch.set_active(global_auto_scale)

        # Runtime monitor info
        state_monitors = data.get("STATE", {}).get("HEADS", [])
        state_by_desc = {mon["DESCRIPTION"]: mon for mon in state_monitors}

        # Combine names:
        all_names = list(dict.fromkeys(state_by_desc.keys()))

        # Build full monitor objects
        full_monitors = []
        for desc in all_names:
            mon = state_by_desc.get(desc)
            if not mon:
                mon = {
                    "DESCRIPTION": desc,
                    "CURRENT": {
                        "ENABLED": False,
                        "MODE": {
                            "WIDTH": 1920,
                            "HEIGHT": 1080,
                            "REFRESH_MHZ": 60000,
                        },
                        "VRR": False,
                        "SCALE": 1.0,
                    },
                    "MODES": []
                }

            # Config TRANSFORM
            for entry in cfg.get("TRANSFORM", []):
                if isinstance(entry, dict) and entry.get("DESCRIPTION") == desc:
                    mon.setdefault("CURRENT", {})["TRANSFORM"] = entry.get("TRANSFORM")

            # Config SCALE
            for entry in cfg.get("SCALE", []):
                if isinstance(entry, dict):
                    tname = entry.get("DESCRIPTION") or entry.get("NAME_DESC")
                    if tname == desc:
                        scale_val = entry.get("SCALE")
                        if isinstance(scale_val, (int, float)):
                            mon["CURRENT"]["SCALE"] = scale_val

            # Default transform fallback
            if "CURRENT" in mon and "TRANSFORM" not in mon["CURRENT"]:
                mon["CURRENT"]["TRANSFORM"] = "NORMAL"

            full_monitors.append(mon)

        # --- Rebuild UI ---
        while self.monitors_notebook.get_n_pages() > 0:
            self.monitors_notebook.remove_page(-1)

        self.monitor_widgets.clear()
        self.monitor_tabs.clear()
        self.monitor_tab_indices.clear()

        for idx, mon in enumerate(full_monitors):
            widget = MonitorWidget(
                mon,
                on_enabled_toggle=self.on_monitor_enabled_toggled,
                on_transform_change=self.on_transform_change,
                on_resolution_change=self.on_resolution_change,
                layout_area=self.layout_area,
            )
            widget.app = self
            self.monitor_widgets.append(widget)


            make = mon.get("MAKE")
            model = mon.get("MODEL")
            name = mon.get("NAME")
            label_text = f"{make} {model} ({name})"
            if not make or not model:
                label_text = f"Unknown ({name})"
            if not mon.get("CURRENT", {}).get("ENABLED", True):
                label_text += " (Disabled)"
            label = Gtk.Label(label=label_text)

            self.monitors_notebook.append_page(widget, label)
            self.monitor_tabs[mon["DESCRIPTION"]] = (widget, label)
            self.monitor_tab_indices[mon["DESCRIPTION"]] = idx

        # Layout area
        enabled_monitors = [m for m in full_monitors if m.get("CURRENT", {}).get("ENABLED", True)]
        align_setting = cfg.get("ALIGN", "TOP")
        arrange = cfg.get("ARRANGE", "ROW")

        self.layout_area = MonitorLayout(
            enabled_monitors,
            self.monitors_notebook,
            self.monitor_tab_indices,
            align=align_setting,
            arrange=arrange
        )

        # Apply transforms to layout
        for mon in enabled_monitors:
            desc = mon["DESCRIPTION"]
            widget = self.monitor_tabs.get(desc, (None,))[0]
            if widget:
                transform = widget.get_transform()
                self.on_transform_change(desc, transform)


    def on_callback_entry_changed(self, entry):
        text = entry.get_text().strip()

        if text:
            # In GTK4, use signal_handler_block_by_func/unblock_by_func
            entry.handler_block_by_func(self.on_callback_entry_changed)
            # Example: ensure it always ends with a semicolon or whatever rule
            if not text.endswith(""):
                entry.set_text(text + "")
                entry.set_position(-1)
            entry.handler_unblock_by_func(self.on_callback_entry_changed)

    def on_notify_toggle(self, switch, _param):
        enabled = switch.get_active()
        default_cmd = 'notify-send "way-displays ${CALLBACK_LEVEL}" "${CALLBACK_MSG}"'
        current = self.callback_entry.get_text().strip()

        if enabled:
            self.callback_entry.set_sensitive(True)
            if not current:
                self.callback_entry.set_text(default_cmd)
            ipc_operation("CFG_SET", f"CFG:\n  CALLBACK_CMD: {self.callback_entry.get_text().strip()}")
        else:
            self.callback_entry.set_sensitive(False)
            self.callback_entry.set_text("")
            ipc_operation("CFG_DEL", f"CFG:\n  CALLBACK_CMD: \"\"")
        get_config_data()

    def on_autoscale_toggle(self, switch, _param):
        enabled = switch.get_active()
        ipc_operation("CFG_SET", f"CFG:\n  AUTO_SCALE: {enabled}")
        get_config_data()

        try:
            data = CONFIG_DATA
            state_monitors = data.get("STATE", {}).get("HEADS", [])
            if not enabled:
                for m in state_monitors:
                    ipc_operation("CFG_DEL", f"CFG:\n  SCALE:\n    - NAME_DESC: {m['DESCRIPTION']}\n      SCALE: 0")
                    get_config_data()

            desc_to_scale = {
                m["DESCRIPTION"]: m.get("CURRENT", {}).get("SCALE", 1.0)
                for m in state_monitors
            }

            # Update each tab's scale slider
            for widget in self.monitor_widgets:
                desc = widget.monitor.get("DESCRIPTION")
                if desc and desc in desc_to_scale:
                    new_scale = desc_to_scale[desc]
                    GLib.idle_add(lambda s=widget.scale_slider, v=new_scale: s.set_value(v))
                    widget.monitor["CURRENT"]["SCALE"] = new_scale

            ipc_operation("CFG_WRITE")
        except Exception as e:
            print(f"[WARN] Failed to refresh monitor states: {e}")
            return

    def on_resolution_change(self, desc, width, height, refresh):
        if not self.layout_area:
            return

        scale = 0.08
        widget = self.layout_area.get_widget_by_desc(desc)
        if not widget:
            return

        for w, data in self.layout_area.monitor_data.items():
            if data["desc"] == desc:
                data["width"] = int(width * scale)
                data["height"] = int(height * scale)
                data["refresh"] = refresh
                label = data.get("label")
                self.layout_area._apply_transform_to_shape(w, data.get("transform"))

                # GTK4: children access changed slightly
                if label:
                    label.set_text(f"{desc}\n{width}x{height} @ {refresh:.2f}Hz")
                break

    def on_transform_change(self, desc, new_transform):
        if not self.layout_area:
            return

        widget = self.layout_area.get_widget_by_desc(desc)
        if not widget:
            return

        self.layout_area.update_widget_transform(widget, new_transform)

        for w, data in self.layout_area.monitor_data.items():
            if data["desc"] == desc:
                current_w = data["width"]
                current_h = data["height"]

                if new_transform and ("90" in new_transform or "270" in new_transform):
                    data["width"], data["height"] = current_h, current_w
                else:
                    # fallback: use current tab to re-fetch base mode dimensions
                    tab_widget = self.monitor_tabs.get(desc, (None,))[0]
                    if tab_widget:
                        state = tab_widget.get_desired_state()
                        scale = 0.08
                        if state:
                            data["width"] = int(state["width"] * scale)
                            data["height"] = int(state["height"] * scale)

                break

        self.layout_area._apply_transform_to_shape(widget, new_transform)


    def on_monitor_enabled_toggled(self, monitor, enabled):
        print(f"[TOGGLE] {monitor['DESCRIPTION']} -> {'ENABLED' if enabled else 'DISABLED'}")
        desc = monitor.get("DESCRIPTION", "Unknown")

        _, label = self.monitor_tabs.get(desc, (None, None))
        if label:
            label.set_text(desc if enabled else f"{desc} (Disabled)")

        if not self.layout_area:
            return

        if enabled:
            self.layout_area.remove_monitor(desc)
            self.layout_area.add_monitor(monitor)
        else:
            self.layout_area.add_monitor(monitor)
            self.layout_area.remove_monitor(desc)

    def save_config(self, button=None):
        data = CONFIG_DATA
        cfg = data.get("CFG", {})

        cfg.setdefault("MODE", [])
        cfg.setdefault("SCALE", [])
        cfg.setdefault("VRR_OFF", [])
        cfg.setdefault("DISABLED", [])
        cfg.setdefault("TRANSFORM", [])

        def upsert_entry(lst, desc_key, desc_value, key, value):
            for entry in lst:
                if isinstance(entry, dict) and (entry.get("DESCRIPTION") == desc_value):
                    entry[key] = value
                    return
            lst.append({desc_key: desc_value, key: value})

        for widget in self.monitor_widgets:
            if isinstance(widget, MonitorWidget):
                state = widget.get_desired_state()
                if not state:
                    continue

                desc = state["desc"]
                w = str(state["width"])
                h = str(state["height"])
                hz = str(state["refresh"] // 1000)
                enabled = state["enabled"]
                vrr = state["vrr"]
                scale = state["scale"]
                transform = state.get("transform")

                upsert_entry(cfg["MODE"], "DESCRIPTION", desc, "WIDTH", int(w))
                upsert_entry(cfg["MODE"], "DESCRIPTION", desc, "HEIGHT", int(h))
                upsert_entry(cfg["MODE"], "DESCRIPTION", desc, "HZ", int(hz))
                upsert_entry(cfg["SCALE"], "DESCRIPTION", desc, "SCALE", float(scale))
                upsert_entry(cfg["TRANSFORM"], "DESCRIPTION", desc, "TRANSFORM", transform)

                ipc_operation("CFG_SET", f"CFG:\n  MODE:\n    - NAME_DESC: {desc}\n      WIDTH: {w}\n      HEIGHT: {h}\n      HZ: {hz}")
                ipc_operation("CFG_SET", f"CFG:\n  VRR_OFF:\n    - {desc}") if not vrr else ipc_operation("CFG_DEL", f"CFG:\n  VRR_OFF:\n    - {desc}")
                ipc_operation("CFG_SET", f"CFG:\n  DISABLED:\n    - {desc}") if not enabled else ipc_operation("CFG_DEL", f"CFG:\n  DISABLED:\n    - {desc}")

                if scale:
                    if scale > 1:
                        ipc_operation("CFG_SET", f"CFG:\n  SCALE:\n    - NAME_DESC: {desc}\n      SCALE: {scale:.2f}")
                    else:
                        ipc_operation("CFG_DEL", f"CFG:\n  SCALE:\n    - NAME_DESC: {desc}\n      SCALE: 0")

                if transform:
                    ipc_operation("CFG_SET", f"CFG:\n  TRANSFORM:\n    - NAME_DESC: {desc}\n      TRANSFORM: {transform}")
                else:
                    ipc_operation("CFG_DEL", f"CFG:\n  TRANSFORM:\n    - NAME_DESC: {desc}\n      TRANSFORM: 90")


        if self.callback_entry.get_text():
            ipc_operation("CFG_DEL", f"CFG:\n  CALLBACK_CMD: \"\"")

        if self.layout_area:
            positions = {}
            transform_map = {
                meta["desc"]: meta.get("transform", "0")
                for meta in self.layout_area.monitor_data.values()
            }
            for eventbox, meta in self.layout_area.monitor_data.items():
                positions[meta["desc"]] = {
                    "x": meta["x"], "y": meta["y"],
                    "w": meta["width"], "h": meta["height"]
                }

            xs = [meta["x"] for meta in positions.values()]
            ys = [meta["y"] for meta in positions.values()]
            auto_arrange = "ROW" if (max(xs) - min(xs)) >= (max(ys) - min(ys)) else "COLUMN"

            # Alignment logic (unchanged)
            if auto_arrange == "ROW" and len(positions) >= 2:
                sorted_items = sorted(positions.items(), key=lambda item: item[1]["x"])
                main_name, main_meta = sorted_items[0]
                neighbor_name, neighbor_meta = sorted_items[1]
                transform_main = transform_map.get(main_name, "0")
                transform_neighbor = transform_map.get(neighbor_name, "0")
                main_w, main_h = rotated_dimensions(main_meta["w"], main_meta["h"], transform_main)
                neighbor_w, neighbor_h = rotated_dimensions(neighbor_meta["w"], neighbor_meta["h"], transform_neighbor)
                main_top = main_meta["y"]
                main_bottom = main_top + main_h
                main_center = main_top + main_h / 2
                neighbor_top = neighbor_meta["y"]
                neighbor_bottom = neighbor_top + neighbor_h
                neighbor_center = neighbor_top + neighbor_h / 2
                top_diff = abs(neighbor_top - main_top)
                mid_diff = abs(neighbor_center - main_center)
                bottom_diff = abs(neighbor_bottom - main_bottom)
                min_diff = min(top_diff, mid_diff, bottom_diff)
                SNAP_TOLERANCE = 100
                if min_diff == mid_diff and mid_diff < SNAP_TOLERANCE:
                    cfg["ALIGN"] = "MIDDLE"
                elif min_diff == bottom_diff and bottom_diff < SNAP_TOLERANCE:
                    cfg["ALIGN"] = "BOTTOM"
                else:
                    cfg["ALIGN"] = "TOP"
            elif auto_arrange == "COLUMN" and len(positions) >= 2:
                sorted_items = sorted(positions.items(), key=lambda item: item[1]["y"])
                main_name, main_meta = sorted_items[0]
                neighbor_name, neighbor_meta = sorted_items[1]
                transform_main = transform_map.get(main_name, "0")
                transform_neighbor = transform_map.get(neighbor_name, "0")
                main_w, main_h = rotated_dimensions(main_meta["w"], main_meta["h"], transform_main)
                neighbor_w, neighbor_h = rotated_dimensions(neighbor_meta["w"], neighbor_meta["h"], transform_neighbor)
                main_left = main_meta["x"]
                main_right = main_left + main_w
                main_center = main_left + main_w / 2
                neighbor_left = neighbor_meta["x"]
                neighbor_right = neighbor_left + neighbor_w
                neighbor_center = neighbor_left + neighbor_w / 2
                left_diff = abs(neighbor_left - main_left)
                mid_diff = abs(neighbor_center - main_center)
                right_diff = abs(neighbor_right - main_right)
                min_diff = min(left_diff, mid_diff, right_diff)
                SNAP_TOLERANCE = 25
                if min_diff == mid_diff and mid_diff < SNAP_TOLERANCE:
                    cfg["ALIGN"] = "MIDDLE"
                elif min_diff == right_diff and right_diff < SNAP_TOLERANCE:
                    cfg["ALIGN"] = "RIGHT"
                else:
                    cfg["ALIGN"] = "LEFT"

            sorted_names = (
                sorted(positions.keys(), key=lambda n: positions[n]["x"])
                if auto_arrange == "ROW"
                else sorted(positions.keys(), key=lambda n: positions[n]["y"])
            )
            cfg["ORDER"] = sorted_names
            ipc_operation("CFG_SET", f"CFG:\n  ORDER:\n    - " + "\n    - ".join(sorted_names))
            cfg["ARRANGE"] = auto_arrange
            self.arrange_mode = cfg["ARRANGE"]
            ipc_operation("CFG_SET", f"CFG:\n  ARRANGE: {cfg['ARRANGE']}\n  ALIGN: {cfg['ALIGN']}")

        ipc_operation("CFG_WRITE")
        get_config_data()
        GLib.timeout_add(250, self.reload_layout)


    def reload_layout(self):
        data = CONFIG_DATA
        cfg = data.get("CFG", {})

        arrange = cfg.get("ARRANGE", "ROW")
        align = cfg.get("ALIGN", "TOP")
        order = cfg.get("ORDER", [])

        transform_overrides = {
            entry.get("NAME_DESC"): entry.get("TRANSFORM")
            for entry in cfg.get("TRANSFORM", [])
        }

        # GTK4: Remove all children from layout_frame
        child = self.layout_frame.get_child()
        if child:
            self.layout_frame.set_child(None)

        if not self.monitor_widgets:
            print("[ERROR] No monitor widgets found â€” skipping layout generation.")
            return

        desc_to_tab_index = {w.monitor["DESCRIPTION"]: i for i, w in enumerate(self.monitor_widgets)}
        monitors_dicts = [w.monitor.copy() for w in self.monitor_widgets]

        self.layout_area = MonitorLayout(
            monitors=monitors_dicts,
            notebook=self.monitors_notebook,
            desc_to_tab_index=desc_to_tab_index,
            align=align,
            arrange=arrange,
            order=order,
            transform_overrides=transform_overrides,
        )

        self.layout_frame.set_child(self.layout_area)

        # propagate new layout_area to all monitor widgets:
        for widget in self.monitor_widgets:
            widget.layout_area = self.layout_area

        # ðŸ‘‰ SHOW OVERLAY FOR ALL MONITORS
        for rotatable, meta in self.layout_area.monitor_data.items():
            GLib.idle_add(
                self.layout_area.show_overlay,
                meta["desc"], meta["width"], meta["height"],
                meta["x"], meta["y"],
                meta["orig_width"], meta["orig_height"],
                meta["name"]
            )

class MainApp(Gtk.Application):
    def __init__(self):
        super().__init__(application_id="com.nobara.WayDisplaysApp")

    def do_activate(self):
        win = WayDisplaysApp(application=self)
        win.present()

if __name__ == '__main__':
    app = MainApp()
    app.run()
